--- grisu3.c
+++ grisu3.c
@@ -1,3 +1,31 @@
+/* Copyright Jukka Jylänki
+   Licensed under the Apache License, Version 2.0 (the "License");
+   you may not use this file except in compliance with the License.
+   You may obtain a copy of the License at
+       http://www.apache.org/licenses/LICENSE-2.0
+   Unless required by applicable law or agreed to in writing, software
+   distributed under the License is distributed on an "AS IS" BASIS,
+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+   See the License for the specific language governing permissions and
+   limitations under the License. */
+
+
+/* Modifcations to dtoa_grisu3() referenced mikkelfj: are under the following
+ * Copyright (c) 2016 Mikkel F. Jørgensen, dvide.com
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License. http://www.apache.org/licenses/LICENSE-2.0
+ */
+
 /* This file is part of an implementation of the "grisu3" double to string
 	conversion algorithm described in the research paper
 
@@ -8,13 +36,9 @@
 #include <stdint.h> // uint64_t etc.
 #include <assert.h> // assert
 #include <math.h> // ceil
-#include <stdio.h> // sprintf
-#include <stddef.h> // ptrdiff_t
-#include <limits.h> // INT_MIN
-#include <string.h> // strcpy
+#include <stdio.h> // snprintf
+#include <string.h>
 
-#include "grisu3.h"
-
 #ifdef _MSC_VER
 #pragma warning(disable : 4204) // nonstandard extension used : non-constant aggregate initializer
 #endif
@@ -287,52 +311,14 @@
 	return success;
 }
 
-int u32_to_hex_string(uint32_t val, char *str)
+static int i_to_str(int val, char *str)
 {
-	assert(str);
-	char *s = str;
-	const char hex[] = "0123456789ABCDEF";
-	for(;;)
-	{
-		*s++ = hex[val & 0xF];
-		val >>= 4;
-		if (val == 0)
-			break;
-	}
-	*s = '\0';
-
-	// TODO: Can avoid reversing in this loop if using builtin_clz to detect the string width beforehand.
-	ptrdiff_t len = s - str;
-	for(int i = 0; i < len>>1; ++i)
-	{
-		char ch = str[i];
-		str[i] = str[len-1-i];
-		str[len-1-i] = ch;
-	}
+	int len, i;
+	char *s;
+	char *begin = str;
+	if (val < 0) { *str++ = '-'; val = -val; }
+	s = str;
 
-	return (int)(s - str);
-}
-
-int i32_to_hex_string(int i, char *str)
-{
-	assert(str);
-	if (i < 0)
-	{
-		*str++ = '-';
-		if (i == INT_MIN)
-		{
-			strcpy(str, "80000000");
-			return 9; // == strlen("-80000000")
-		}
-		return u32_to_string((uint32_t)-i, str) + 1;
-	}
-	return u32_to_string((uint32_t)i, str);
-}
-
-int u32_to_string(uint32_t val, char *str)
-{
-	assert(str);
-	char *s = str;
 	for(;;)
 	{
 		int ni = val / 10;
@@ -343,31 +329,15 @@
 		val = ni;
 	}
 	*s = '\0';
-	ptrdiff_t len = s - str;
-	for(int i = 0; i < len>>1; ++i)
+	len = (int)(s - str);
+	for(i = 0; i < len/2; ++i)
 	{
 		char ch = str[i];
 		str[i] = str[len-1-i];
 		str[len-1-i] = ch;
 	}
 
-	return (int)(s - str);
-}
-
-int i32_to_string(int i, char *str)
-{
-	assert(str);
-	if (i < 0)
-	{
-		*str++ = '-';
-		if (i == INT_MIN)
-		{
-			strcpy(str, "2147483648");
-			return 11; // == strlen("-2147483648")
-		}
-		return u32_to_string((uint32_t)-i, str) + 1;
-	}
-	return u32_to_string((uint32_t)i, str);
+	return (int)(s - begin);
 }
 
 int dtoa_grisu3(double v, char *dst)
@@ -378,18 +348,11 @@
 	assert(dst);
 
 	// Prehandle NaNs
-	if ((u64 << 1) > 0xFFE0000000000000ULL)
-	{
-#ifdef __EMSCRIPTEN__
-		*dst++ = 'N';
-		*dst++ = 'a';
-		*dst++ = 'N';
-		*dst = '\0';
-		return 3;
-#else
-		return sprintf(dst, "NaN(%08X%08X)", (uint32_t)(u64 >> 32), (uint32_t)u64);
-#endif
-	}
+	// Why size = 22?
+	//  5 for "NaN()"
+	// 16 for two hexadecimal intgers at width 8
+	//  1 for null terminator
+	if ((u64 << 1) > 0xFFE0000000000000ULL) return snprintf(dst, 22, "NaN(%08X%08X)", (uint32_t)(u64 >> 32), (uint32_t)u64);
 	// Prehandle negative values.
 	if ((u64 & D64_SIGN) != 0) { *s2++ = '-'; v = -v; u64 ^= D64_SIGN; }
 	// Prehandle zero.
@@ -399,45 +362,57 @@
 
 	success = grisu3(v, s2, &len, &d_exp);
 	// If grisu3 was not able to convert the number to a string, then use old sprintf (suboptimal).
-	if (!success)
-	{
-#ifdef __EMSCRIPTEN__
-		return js_double_to_string(v, dst);
-#else
-		return sprintf(s2, "%.17g", v) + (int)(s2 - dst);
-#endif
-	}
+	// (Putative) rationale for size = 30:
+	// 17 digits after decimal at most
+	//  1 for the `.`
+	//  1 for a possible `-`, if the number is negative
+	//  5 for a possible e+308 if it chooses exponential form and uses the largest
+	//    exponent possible
+	//  1 for null terminator
+	// --
+	// 25 total so far
+	//  5 left for displaying the value before the decimal (in the worst case,
+	//    which I'm not even sure is possible)
+	// More context: when vroom calls dtoa_grisu3(), dst points to a buffer of
+	// size 33 (at the time of writing), and that's where s2 starts out FWIW.
+	if (!success) return snprintf(s2, 30, "%.17g", v) + (int)(s2 - dst);
 
-    // We now have an integer string of form "151324135" and a base-10 exponent for that number.
-    // Next, decide the best presentation for that string by whether to use a decimal point, or the scientific exponent notation 'e'.
-    // We don't pick the absolute shortest representation, but pick a balance between readability and shortness, e.g.
-    // 1.545056189557677e-308 could be represented in a shorter form
-    // 1545056189557677e-323 but that would be somewhat unreadable.
+	// handle whole numbers as integers if they are < 10^15
+	if (d_exp >= 0 && d_exp <= MAX(2, 15 - len)) {
+		while(d_exp-- > 0) s2[len++] = '0';
+		s2[len] = '\0';
+		return (int)(s2+len-dst);
+	}
+	// We now have an integer string of form "151324135" and a base-10 exponent for that number.
+	// Next, decide the best presentation for that string by whether to use a decimal point, or the scientific exponent notation 'e'.
+	// We don't pick the absolute shortest representation, but pick a balance between readability and shortness, e.g.
+	// 1.545056189557677e-308 could be represented in a shorter form
+	// 1545056189557677e-323 but that would be somewhat unreadable.
 	decimals = MIN(-d_exp, MAX(1, len-1));
-	if (d_exp < 0 && len > 1) // Add decimal point?
+	// mikkelfj:
+	// fix zero prefix .1 => 0.1, important for JSON export.
+	// prefer unscientific notation at same length:
+	// -1.2345e-4 over -1.00012345,
+	// -1.0012345 over -1.2345e-3
+	if (d_exp < 0 && (len + d_exp) > -3 && len <= -d_exp)
 	{
+		// mikkelfj: fix zero prefix .1 => 0.1, and short exponents 1.3e-2 => 0.013.
+		memmove(s2 + 2 - d_exp - len, s2, len);
+		s2[0] = '0';
+		s2[1] = '.';
+		for (i = 2; i < 2-d_exp-len; ++i) s2[i] = '0';
+		len += i;
+	}
+	else if (d_exp < 0 && len > 1) // Add decimal point?
+	{
 		for(i = 0; i < decimals; ++i) s2[len-i] = s2[len-i-1];
 		s2[len++ - decimals] = '.';
 		d_exp += decimals;
 		// Need scientific notation as well?
-		if (d_exp != 0) { s2[len++] = 'e'; len += i32_to_string(d_exp, s2+len); }
-	}
-	else if (d_exp < 0 && d_exp >= -3) // Add decimal point for numbers of form 0.000x where it's shorter?
-	{
-		for(i = 0; i < len; ++i) s2[len-d_exp-1-i] = s2[len-i-1];
-		s2[0] = '.';
-		for(i = 1; i < -d_exp; ++i) s2[i] = '0';
-		len += -d_exp;
-	}
-	// Add scientific notation?
-	else if (d_exp < 0 || d_exp > 2) { s2[len++] = 'e'; len += i32_to_string(d_exp, s2+len); }
+		if (d_exp != 0) { s2[len++] = 'e'; len += i_to_str(d_exp, s2+len); }
+	}// Add scientific notation?
+	else if (d_exp < 0 || d_exp > 2) { s2[len++] = 'e'; len += i_to_str(d_exp, s2+len); }
 	// Add zeroes instead of scientific notation?
-	else if (d_exp > 0) { while(d_exp-- > 0) s2[len++] = '0'; }
-	s2[len] = '\0'; // grisu3 doesn't null terminate, so ensure termination.
+	/*s2[len] = '\0'; // grisu3 doesn't null terminate, so ensure termination.*/
 	return (int)(s2+len-dst);
 }
-
-int f32_to_string(float v, char *dst)
-{
-	return dtoa_grisu3((double)v, dst);
-}
