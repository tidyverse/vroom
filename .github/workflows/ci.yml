name: CI

on:
  push:
    branches: [ main, master ]
  pull_request:
    branches: [ main, master ]

jobs:
  build-and-test:
    name: ${{ matrix.os }} - ${{ matrix.build_type }}
    runs-on: ${{ matrix.os }}

    strategy:
      fail-fast: false
      matrix:
        os: [ubuntu-latest, macos-latest]
        build_type: [Release, Debug]
        exclude:
          # Skip Debug on macOS - Debug is mainly for coverage which runs on Linux
          - os: macos-latest
            build_type: Debug

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Install dependencies (Ubuntu)
      if: runner.os == 'Linux'
      run: |
        sudo apt-get update
        sudo apt-get install -y cmake build-essential ccache

    - name: Install dependencies (macOS)
      if: runner.os == 'macOS'
      run: |
        brew install cmake ccache zstd lz4 snappy

    - name: Cache ccache
      uses: actions/cache@v4
      with:
        path: |
          ~/.cache/ccache
          ~/Library/Caches/ccache
        key: ccache-${{ runner.os }}-${{ matrix.build_type }}-${{ github.sha }}
        restore-keys: |
          ccache-${{ runner.os }}-${{ matrix.build_type }}-

    - name: Configure ccache
      run: |
        ccache --set-config=max_size=500M
        ccache --set-config=compression=true
        ccache -z

    - name: Cache FetchContent dependencies
      uses: actions/cache@v4
      with:
        path: build/_deps
        key: deps-${{ runner.os }}-${{ matrix.build_type }}-${{ hashFiles('CMakeLists.txt') }}
        restore-keys: |
          deps-${{ runner.os }}-${{ matrix.build_type }}-

    - name: Configure CMake (Linux)
      if: runner.os == 'Linux'
      run: |
        cmake -B build -DCMAKE_BUILD_TYPE=${{ matrix.build_type }}

    - name: Configure CMake (macOS)
      if: runner.os == 'macOS'
      run: |
        cmake -B build -DCMAKE_BUILD_TYPE=${{ matrix.build_type }} -DCMAKE_PREFIX_PATH=/opt/homebrew

    - name: Build
      run: |
        cmake --build build --config ${{ matrix.build_type }} -j

    - name: Show ccache stats
      run: |
        ccache -s

    - name: Run all tests with CTest
      run: |
        cd build && ctest --output-on-failure --build-config ${{ matrix.build_type }} -j

  # GCC-based coverage (gcov/lcov) - traditional approach
  # Note: gcov has known limitations with header-only code attribution.
  # Template and inline code in headers may be attributed to .cpp files.
  # See docs/coverage.md for details.
  coverage:
    name: Code Coverage (GCC/lcov)
    runs-on: ubuntu-latest

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Install dependencies
      run: |
        sudo apt-get update
        sudo apt-get install -y cmake build-essential lcov

    - name: Cache FetchContent dependencies
      uses: actions/cache@v4
      with:
        path: build/_deps
        key: deps-Linux-Debug-${{ hashFiles('CMakeLists.txt') }}
        restore-keys: |
          deps-Linux-Debug-

    - name: Configure CMake with coverage
      run: |
        cmake -B build -DCMAKE_BUILD_TYPE=Debug -DENABLE_COVERAGE=ON

    - name: Build with coverage
      run: |
        cmake --build build -j

    - name: Run tests
      run: |
        cd build && ctest --output-on-failure -j

    - name: Generate coverage info
      run: |
        cd build
        # Capture coverage using the config file from repo root
        # Enable branch coverage with --rc branch_coverage=1
        lcov --config-file ../.lcovrc --rc branch_coverage=1 --capture --directory . --output-file coverage.info --ignore-errors mismatch,unused
        # Remove test, benchmark, and external dependencies from coverage
        lcov --config-file ../.lcovrc --rc branch_coverage=1 --remove coverage.info '*/test/*' '*/benchmark/*' '*/build/_deps/*' '/usr/*' --output-file coverage.info --ignore-errors unused
        # Show what files remain in the coverage report
        echo "=== Files in final coverage report ==="
        lcov --list coverage.info
        echo "=== Coverage Summary (including branch coverage) ==="
        lcov --rc branch_coverage=1 --summary coverage.info
        echo "=== Verifying no test/benchmark files remain ==="
        if grep -E "^SF:.*/test/|^SF:.*/benchmark/" coverage.info; then
          echo "ERROR: test or benchmark files found in coverage report!"
          exit 1
        else
          echo "OK: No test or benchmark files in coverage report"
        fi

    - name: Upload coverage to Codecov
      uses: codecov/codecov-action@v4
      if: github.repository == 'jimhester/libvroom'
      continue-on-error: true
      with:
        files: ./build/coverage.info
        flags: gcov
        fail_ci_if_error: false
        verbose: true
        token: ${{ secrets.CODECOV_TOKEN }}

  # Clang source-based coverage - provides accurate header file attribution
  # This approach correctly attributes template/inline code to header files.
  # See: https://clang.llvm.org/docs/SourceBasedCodeCoverage.html
  coverage-llvm:
    name: Code Coverage (Clang/llvm-cov)
    runs-on: ubuntu-latest

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Install dependencies
      run: |
        sudo apt-get update
        sudo apt-get install -y cmake clang llvm

    - name: Cache FetchContent dependencies
      uses: actions/cache@v4
      with:
        path: build/_deps
        key: deps-Linux-Clang-Debug-${{ hashFiles('CMakeLists.txt') }}
        restore-keys: |
          deps-Linux-Clang-Debug-

    - name: Configure CMake with LLVM coverage
      run: |
        cmake -B build \
          -DCMAKE_BUILD_TYPE=Debug \
          -DCMAKE_C_COMPILER=clang \
          -DCMAKE_CXX_COMPILER=clang++ \
          -DENABLE_LLVM_COVERAGE=ON

    - name: Build with coverage
      run: |
        cmake --build build -j

    - name: Run tests and collect coverage
      run: |
        cd build
        # Set up profile output path
        export LLVM_PROFILE_FILE="coverage-%p.profraw"
        # Run all tests
        ctest --output-on-failure -j

    - name: Generate coverage report
      run: |
        cd build
        # Find llvm-profdata and llvm-cov (version may vary)
        LLVM_PROFDATA=$(which llvm-profdata || find /usr -name 'llvm-profdata*' -type f | head -1)
        LLVM_COV=$(which llvm-cov || find /usr -name 'llvm-cov*' -type f | head -1)

        echo "Using llvm-profdata: $LLVM_PROFDATA"
        echo "Using llvm-cov: $LLVM_COV"

        # Merge raw profiles
        $LLVM_PROFDATA merge -sparse coverage-*.profraw -o coverage.profdata

        # Find all test executables (they contain the coverage mapping)
        TEST_BINARIES=$(find . -maxdepth 1 -type f -executable -name '*_test' | tr '\n' ' ')
        VROOM_CLI="./vroom"

        # Create object list for llvm-cov
        OBJECTS=""
        for bin in $TEST_BINARIES; do
          OBJECTS="$OBJECTS -object $bin"
        done
        if [ -f "$VROOM_CLI" ]; then
          OBJECTS="$OBJECTS -object $VROOM_CLI"
        fi

        # Generate coverage report in lcov format
        # Use the first test binary as the main binary, others as objects
        FIRST_BIN=$(echo $TEST_BINARIES | cut -d' ' -f1)
        $LLVM_COV export $FIRST_BIN $OBJECTS \
          -instr-profile=coverage.profdata \
          -format=lcov \
          -ignore-filename-regex='(test/|benchmark/|_deps/|/usr/)' \
          > coverage-llvm.info

        # Show summary
        echo "=== LLVM Coverage Summary ==="
        $LLVM_COV report $FIRST_BIN $OBJECTS \
          -instr-profile=coverage.profdata \
          -ignore-filename-regex='(test/|benchmark/|_deps/|/usr/)' \
          --show-region-summary=false

        echo ""
        echo "=== Header File Coverage ==="
        $LLVM_COV report $FIRST_BIN $OBJECTS \
          -instr-profile=coverage.profdata \
          -ignore-filename-regex='(test/|benchmark/|_deps/|/usr/)' \
          --show-region-summary=false | grep -E '\.h$' || echo "No header files in report"

    - name: Upload LLVM coverage to Codecov
      uses: codecov/codecov-action@v4
      if: github.repository == 'jimhester/libvroom'
      continue-on-error: true
      with:
        files: ./build/coverage-llvm.info
        flags: llvm
        fail_ci_if_error: false
        verbose: true
        token: ${{ secrets.CODECOV_TOKEN }}

  minimal-release-build:
    name: Minimal Release Build
    runs-on: ubuntu-latest
    # Only run on main branch pushes - tests CMake config, not code changes
    if: github.event_name == 'push' && github.ref == 'refs/heads/main'

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Install dependencies
      run: |
        sudo apt-get update
        sudo apt-get install -y cmake build-essential

    - name: Configure minimal release build
      run: |
        cmake -B build -DCMAKE_BUILD_TYPE=Release -DBUILD_TESTING=OFF -DBUILD_BENCHMARKS=OFF

    - name: Build
      run: |
        cmake --build build --config Release -j

    - name: Verify expected artifacts exist
      run: |
        echo "Checking for library..."
        if ls build/libvroom.* 1>/dev/null 2>&1; then
          echo "✓ Library found:"
          ls -la build/libvroom.*
        else
          echo "✗ Library not found!"
          exit 1
        fi

        echo "Checking for vroom binary..."
        if [ -f build/vroom ]; then
          echo "✓ vroom binary found:"
          ls -la build/vroom
        else
          echo "✗ vroom binary not found!"
          exit 1
        fi

    - name: Smoke test vroom binary
      run: |
        echo "Running smoke test: vroom --help"
        ./build/vroom --help
        echo "✓ vroom binary runs successfully"

    - name: Verify test executables are NOT built
      run: |
        echo "Verifying test executables are not present..."
        TEST_EXECUTABLES="libvroom_test error_handling_test csv_parsing_test csv_parser_errors_test csv_extended_test dialect_detection_test type_detection_test c_api_test debug_test api_test quote_mask_test value_extraction_test streaming_test branchless_test simd_number_parsing_test io_util_test cli_test two_pass_coverage_test"

        FOUND_TESTS=""
        for test in $TEST_EXECUTABLES; do
          if [ -f "build/$test" ]; then
            FOUND_TESTS="$FOUND_TESTS $test"
          fi
        done

        if [ -n "$FOUND_TESTS" ]; then
          echo "✗ Test executables were built but should not have been:$FOUND_TESTS"
          exit 1
        fi
        echo "✓ No test executables found (as expected)"

    - name: Verify benchmark executables are NOT built
      run: |
        echo "Verifying benchmark executables are not present..."
        BENCHMARK_EXECUTABLES="libvroom_benchmark quote_mask_benchmark"

        FOUND_BENCHMARKS=""
        for bench in $BENCHMARK_EXECUTABLES; do
          if [ -f "build/$bench" ]; then
            FOUND_BENCHMARKS="$FOUND_BENCHMARKS $bench"
          fi
        done

        if [ -n "$FOUND_BENCHMARKS" ]; then
          echo "✗ Benchmark executables were built but should not have been:$FOUND_BENCHMARKS"
          exit 1
        fi
        echo "✓ No benchmark executables found (as expected)"

  shared-library-build:
    name: Shared Library Build
    runs-on: ubuntu-latest

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Install dependencies
      run: |
        sudo apt-get update
        sudo apt-get install -y cmake build-essential

    - name: Configure shared library build
      run: |
        cmake -B build -DCMAKE_BUILD_TYPE=Release -DBUILD_SHARED_LIBS=ON

    - name: Build
      run: |
        cmake --build build --config Release -j

    - name: Verify shared library exists
      run: |
        echo "Checking for shared library (.so)..."
        if ls build/libvroom.so* 1>/dev/null 2>&1; then
          echo "✓ Shared library found:"
          ls -la build/libvroom.so*
        else
          echo "✗ Shared library not found!"
          ls -la build/
          exit 1
        fi

    - name: Verify vroom binary exists and links correctly
      run: |
        echo "Checking for vroom binary..."
        if [ -f build/vroom ]; then
          echo "✓ vroom binary found:"
          ls -la build/vroom
        else
          echo "✗ vroom binary not found!"
          exit 1
        fi

    - name: Test vroom can execute
      run: |
        echo "Testing vroom execution with LD_LIBRARY_PATH..."
        export LD_LIBRARY_PATH="${PWD}/build:${LD_LIBRARY_PATH}"
        ./build/vroom --help

